A library to output quality backtraces if an unhandled exception occurs:


ex:
ruby -rbacktrace_with_code_and_locals crash.rb

unhandled exception: crash.rb:6:   raise
        locals: {"a"=>"3", "b"=>3, "within_go2"=>4}
          from:
        crash.rb:1 go2(a=>3, b=>55)
                locals: {"a"=>"3", "b"=>3, "within_go2"=>4}
        crash.rb:8 go(a=>3)
                locals: {"a"=>"3", "within_go"=>2}

Wasn't that pretty?
Drawback: makes your script run much more slowly.
backtrace_all_lines doesn't have that disadvantage, but doesn't output things as pretty. 

try them all out, some are more verbose than others.

TODO make backtrace_all_lines lookup code lines at_exit

Note also that you could require a file sometime 'mid stream' and it would track thread backtraces from then on


if you run it in VERBOSE mode it outputs each call as its made
ruby -v -rbacktracer crash.rb

#0:crash.rb:1::-: def go2(a, b)
 |#0:crash.rb:1:Module:>: def go2(a, b)                                                            1,3-10 Allargs were [["topmost", nil]]
#0:crash.rb:1:Module:<: def go2(a, b) raise
#0:crash.rb:8::-: def go(a);
 |#0:crash.rb:8:Module:>: def go(a);
args were [["topmost", nil]]
#0:crash.rb:8:Module:<: def go(a);
#0:crash.rb:14::-: topmost =1  raise
#0:crash.rb:15::-: go '3'
 |#0:crash.rb:8:Object:>: def go(a); s] (22:09 10/01/2009)                                              1
args were [["a", "3"]]
... [there's more]
unhandled exception: crash.rb:6:   raise
        locals: {"a"=>"3", "b"=>3, "within_go2"=>4}
          from:
        crash.rb:1 go2(a=>3, b=>55)
                locals: {"a"=>"3", "b"=>3, "within_go2"=>4}
        crash.rb:8 go(a=>3)
                locals: {"a"=>"3", "within_go"=>2}


depends on ruby-debug [MRI] gem

related projects: unroller, this: http://eigenclass.org/hiki/method+arguments+via+introspection, liveconsole
